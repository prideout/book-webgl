\chapter{Preliminaries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Brief History of *GL}
\summary{Gives an account of WebGL's ancestry (OpenGL, OpenGL ES), motivation, and rapid growth.  Also briefly mentions impediments at the time of writing, such as security concerns and IE support.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Giza: Literate Programming}
\summary{Describes our coding conventions and the \code{giza} library that is developed over the course of the book.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Assembly Line Metaphor}
\summary{High-level overview of the WebGL rendering pipeline.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Canvas Element}

\summary{Explains the \code{width} and \code{height} attributes and how to handle high-dpi displays (e.g., Apple Retina).}

The \code{\index{canvas}} element is one of the cornerstones of the HTML5 platform.  It provides rich drawing API's for both 2D and 3D graphics.  The 2D API will not be discussed much in this book (except briefly in Chapter 8), and the 3D API is, of course, WebGL.

\subsection{Dealing with Size and High-Resolution Screens}

By default, \code{<canvas>} is a block level element, similar to \code{<div>}.  This means that it can only be a child of <body>, and that it typically has line breaks before and after it.

However canvas is set apart from other HTML element in that it's controlled by two separate \index{size}s.  First, there's the \emph{display area}, which is determined with familiar \index{CSS} mechanisms, then there's the canvas-specific \emph{content size}, which is specified with explicit \code{\index{width}} and \code{\index{height}} attributes.  The content size specifies an off-screen drawing surface that is scaled into the display area on the web page.

It's tempting to simply set the content and display sizes to the same dimensions, as in:

\begin{lstlisting}[language=HTML]
<canvas style="width:640px;height:360px" width="640" height="360">
</canvas>
\end{lstlisting}

There's nothing wrong with this for simple applications.  However you may wish to have a dynamic style (e.g., \code{width:100%}).  Moreover CSS pixels don't necessarily correspond to actual device pixels.  This is especially true on high-resolution displays like Apple Retina, where browsers typically upscale CSS pixels by 2x. If you assume that device pixels are 1:1 with CSS pixels, you might see ``blurriness'' in your WebGL canvas due to the upscaling.

To get around these issues, \index{\code{GIZA.init}} examines the \code{devicePixelRatio} window property to check how much (if any) upscaling the browser is performing.  It also examines the \index{\code{clientWidth}} and \index{\code{clientHeight}} properties of the canvas element to see what the finalized display style is.

\begin{lstlisting}[language=JavaScript]
GIZA.init = function(canvasElement) {

  // Find a canvas element if one wasn't specified.
  var canvas = canvasElement;
  if (!canvas) {
    canvas = document.getElementsByTagName('canvas')[0];
  }

  // Obtain the browser's upscale amount, assuming 1 if unavailable.
  var pixelScale = window.devicePixelRatio || 1;

  // Define a function that adjusts content size.
  var adjustSize = function() {
    var displayWidth = canvas.clientWidth;
    var displayHeight = canvas.clientHeight;
    canvas.width = displayWidth * pixelScale;
    canvas.height = displayHeight * pixelScale;
  };

  adjustSize();
  window.onresize = adjustSize;
\end{lstlisting}

In Listing~BLAH, we adjust the canvas width and height not only during initialization, but also during the window's \index{\code{onresize}} event.

MARGIN NOTE
\begin{comment}
Some developers also recompute the WebGL \emph{viewport} and \emph{projection matrix} during a resize event; more on this in future chapters.
\end{comment}

\subsection{Getting a Context}

The entire WebGL API is exposed through a drawing \index{context} object of type \index{\code{WebGLRenderingContext}}.  This object is obtained by calling \index{\code{getContext}} on a canvas element, like so:

\begin{lstlisting}[language=JavaScript]
  gl = canvas.getContext('experimental-webgl', {antialias: true});
\end{lstlisting}

At the time of this writing, ``\index{experimental-webgl}'' is the only string that can be passed to \code{getContext} for WebGL.  (For the 2D canvas API, the string ``2d'' is used.

The second argument is a set of optional attributes, as specified in Table~\ref{ContextAttributes}.

\begin{table}[htb]\centering
  \begin{tabular}{ll}
    \hline
    Key & Default Value & Description \\
    \hline
    alpha & true & Alpha channel in FBO 0 \\
    depth & true & Depth buffer in FBO 0 \\
    stencil & false & Stencil buffer in FBO 0 \\
    antialias & true & Enables multisampling (or supersampling) \\
    premultipliedAlpha & true & Specifies compositing behavior with the web page; ignored if alpha is false \\
    preserveDrawingBuffer & false & Automatically resets the draw buffer, independently of \code{gl.clear} \\
    \hline
  \end{tabular}
  \caption{WebGL Context Options.}
  \label{ContextAttributes}
\end{table}

\notetoself{Add references to future sections in the book that deal with context loss and image capture.}

\subsection{Clearing and Compositing}

``Html Page Compositor''

MARGIN NOTE
\begin{comment}
In this book, we never author children of canvas, but there's nothing wrong with doing so.
\end{comment}

...

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Animation Timing}
\summary{How to periodically trigger draw events.}

\begin{lstlisting}[language=JavaScript]
  window.requestAnimationFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\rrecipe{Recipe 1: Strobe Light}
\summary{The simplest possible WebGL application; animates a solid color with \code{clear}.}

