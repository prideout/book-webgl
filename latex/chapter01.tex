\chapter{Preliminaries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Brief History of *GL}
\summary{Gives an account of WebGL's ancestry (OpenGL, OpenGL ES), motivation, and rapid growth.  Also briefly mentions impediments at the time of writing, such as security concerns and IE support.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Giza: Literate Programming}
\summary{Describes our coding conventions and the \texttt{giza} library that is developed over the course of the book.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Assembly Line Metaphor}
\summary{High-level overview of the WebGL rendering pipeline.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Canvas Element}

\summary{Explains the \texttt{width} and \texttt{height} attributes and how to handle high-dpi displays (e.g., Apple Retina).}

The \texttt{\index{canvas}} element is one of the cornerstones of the HTML5 platform.  It provides rich drawing API's for both 2D and 3D graphics.  The 2D API will not be discussed much in this book (except briefly in Chapter 8), and the 3D API is, of course, WebGL.

\subsection{Dealing with Size and High-Resolution Screens}

By default, \texttt{<canvas>} is a block level element, similar to \texttt{<div>}.  This means that it can only be a child of <body>, and that it typically has line breaks before and after it.

However canvas is set apart from other HTML element in that it's controlled by two separate \index{size}s.  First, there's the \emph{display area}, which is determined with familiar \index{CSS} mechanisms, then there's the canvas-specific \emph{content size}, which is specified with explicit \texttt{\index{width}} and \texttt{\index{height}} attributes.  The content size specifies an off-screen drawing surface that is scaled into the display area on the web page.

It's tempting to simply set the content and display sizes to the same dimensions, as in:

\begin{lstlisting}[language=HTML]
<canvas style="width:640px;height:360px" width="640" height="360">
</canvas>
\end{lstlisting}

There's nothing wrong with this for simple applications.  However you may wish to have a dynamic style (e.g., \texttt{width:100%}).  Moreover CSS pixels don't necessarily correspond to actual device pixels.  This is especially true on high-resolution displays like Apple Retina, where browsers typically upscale CSS pixels by 2x. If you assume that device pixels are 1:1 with CSS pixels, you might see ``blurriness'' in your WebGL canvas due to the upscaling.

To get around these issues, \index{\texttt{GIZA.init}} examines the \texttt{devicePixelRatio} window property to check how much (if any) upscaling the browser is performing.  It also examines the \index{\texttt{clientWidth}} and \index{\texttt{clientHeight}} properties of the canvas element to see what the finalized display style is.

\begin{lstlisting}[language=JavaScript]
GIZA.init = function(canvasElement) {

  // Find a canvas element if one wasn't specified.
  var canvas = canvasElement;
  if (!canvas) {
    canvas = document.getElementsByTagName('canvas')[0];
  }

  // Obtain the browser's upscale amount, assuming 1 if unavailable.
  var pixelScale = window.devicePixelRatio || 1;

  // Define a function that adjusts content size.
  var adjustSize = function() {
    var displayWidth = canvas.clientWidth;
    var displayHeight = canvas.clientHeight;
    canvas.width = displayWidth * pixelScale;
    canvas.height = displayHeight * pixelScale;
  };

  adjustSize();
  window.onresize = adjustSize;

\end{lstlisting}

\subsection{Getting a Context}

The entire WebGL API is exposed through a context object....

\begin{lstlisting}[language=JavaScript]
  gl = canvas.getContext('experimental-webgl', {antialias: true});
\end{lstlisting}

RED NOTE: Add a reference to a future section in the book that deals with context loss.

\subsection{Compositing and Children}

CAN THIS BE A SIDEBAR OF SOME SORT?

In this book, we never author children of canvas, but there's nothing wrong with doing so.

...

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Animation Timing}
\summary{How to periodically trigger draw events.}

\begin{lstlisting}[language=JavaScript]
  window.requestAnimationFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\rrecipe{Recipe 1: Strobe Light}
\summary{The simplest possible WebGL application; animates a solid color with \texttt{clear}.}
