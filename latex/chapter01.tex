\chapter{Preliminaries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Brief History of *GL}
\summary{Gives an account of WebGL's ancestry (OpenGL, OpenGL ES), motivation, and rapid growth.  Also briefly mentions impediments at the time of writing, such as security concerns and IE support.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Giza: Literate Programming}
\summary{Describes our coding conventions and the \code{giza} library that is developed over the course of the book.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Assembly Line Metaphor}
\summary{High-level overview of the WebGL rendering pipeline.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Canvas Element}

\summary{Explains the \code{width} and \code{height} attributes and how to handle high-dpi displays (e.g., Apple Retina).}

The \code{\index{canvas}} element is one of the cornerstones of the HTML5 platform.  It provides rich drawing API's for both 2D and 3D graphics.  The 2D API will not be discussed much in this book (except briefly in Chapter 8), and the 3D API is, of course, WebGL.

\subsection{Dealing with Size and High-Resolution Screens}

By default, \code{<canvas>} is a block level element, similar to \code{<div>}.  This means that it can only be a child of \code{<body>}, and that it typically has line breaks before and after it.

One distinction between canvas and other HTML elements is that it has two sets of \index{size}s.  First, there's its \emph{display area}, which is determined with familiar \index{CSS} mechanisms, then there's the canvas-specific \emph{content size}, which is specified with explicit \code{\index{width}} and \code{\index{height}} attributes.  The content size specifies an off-screen drawing surface that is scaled into the display area on the web page.

It's tempting to simply set the content and display sizes to the same dimensions, as in:

\begin{lstlisting}[language=HTML]
<canvas style="width:640px;height:360px" width="640" height="360">
</canvas>
\end{lstlisting}

There's nothing wrong with this for simple applications.  However you may wish to have a dynamic style (e.g., \code{width:100%}).  Moreover CSS pixels don't necessarily correspond to actual device pixels.  This is especially true on high-resolution displays like Apple Retina, where browsers typically upscale CSS pixels by 2x. If you assume that device pixels are 1:1 with CSS pixels, you might see ``blurriness'' in your WebGL canvas due to the upscaling.

To get around these issues, \index{\code{GIZA.init}} examines the \code{devicePixelRatio} window property to check how much (if any) upscaling the browser is performing.  It also examines the \index{\code{clientWidth}} and \index{\code{clientHeight}} properties of the canvas element to see what the finalized display style is.

\begin{lstlisting}[language=JavaScript]
GIZA.init = function(canvasElement) {

  // Find a canvas element if one wasn't specified.
  var canvas = canvasElement;
  if (!canvas) {
    canvas = document.getElementsByTagName('canvas')[0];
  }

  // Obtain the browser's upscale amount, assuming 1 if unavailable.
  var pixelScale = window.devicePixelRatio || 1;

  // Define a function that adjusts content size.
  var adjustSize = function() {
    var displayWidth = canvas.clientWidth;
    var displayHeight = canvas.clientHeight;
    canvas.width = displayWidth * pixelScale;
    canvas.height = displayHeight * pixelScale;
  };

  adjustSize();
  window.onresize = adjustSize;
\end{lstlisting}

In Listing~BLAH, we adjust the canvas width and height not only during initialization, but also during the window's \index{\code{onresize}} event.

MARGIN NOTE
\begin{comment}
It's also common to adjust the WebGL \emph{viewport} and \emph{projection matrix} during a resize event; more on this in future chapters.
\end{comment}

\subsection{Getting a Context}

The entire WebGL API is exposed through a drawing \index{context} object of type \index{\code{WebGLRenderingContext}}.  This object is obtained by calling \index{\code{getContext}} on a canvas element, like so:

\begin{lstlisting}[language=JavaScript]
  gl = canvas.getContext('experimental-webgl', {antialias: true});
\end{lstlisting}

At the time of this writing, ``\index{experimental-webgl}'' is the only string that can be passed to \code{getContext} for WebGL.  (For the 2D canvas API, the string ``2d'' is used.)

The second argument is a set of optional attributes, as specified in Table~\ref{tab:ContextAttributes}.

\begin{table}[htb]\centering
  \begin{tabular}{ll}
    \hline
    Key & Default Value & Description \\
    \hline
    alpha & true & Alpha channel in FBO 0 \\
    depth & true & Depth buffer in FBO 0 \\
    stencil & false & Stencil buffer in FBO 0 \\
    antialias & true & Enables multisampling (or supersampling) \\
    premultipliedAlpha & true & Specifies compositing behavior with the web page; ignored if alpha is false \\
    preserveDrawingBuffer & false & Automatically resets the draw buffer, independently of \code{gl.clear} \\
    \hline
  \end{tabular}
  \caption{WebGL Context Options.}
  \label{tab:ContextAttributes}
\end{table}

\notetoself{Add references to future sections in the book that deal with context loss and image capture.}

\subsection{Clearing and Compositing}

The only WebGL functions we're discussing in this chapter are the first two methods listed in Table~\ref{tab:Clearing}.

\begin{table}[htb]\centering
  \begin{tabular}{ll}
    \hline
    Method & Argument Types \\
    \hline
    clear(mask) & logical or of values in \Table~\ref{tab:ClearBits} \\
    clearColor(red, green, blue, alpha)  & floating point numbers in [0,1] \\
    clearDepth(value) & floating point number in [0,1] \\
    clearStencil(mask) & integer \\
    \hline
  \end{tabular}
  \caption{WebGL Clear Methods.}
  \label{tab:Clearing}
\end{table}

\begin{table}[htb]\centering
  \begin{tabular}{ll}
    \hline
    Property & Value & Default Value \\
    \hline
    DEPTH\_BUFFER\_BIT   & 0x0100 & 0.0 \\
    STENCIL\_BUFFER\_BIT & 0x0400 & 0x00000000\\
    COLOR\_BUFFER\_BIT   & 0x4000 & (0, 0, 0, 0) \\
    \hline
  \end{tabular}
  \caption{WebGL Clear Bits.}
  \label{tab:ClearBit}
\end{table}

BRIEFLY DESCRIBE ``PLANES'', DEPTH, and STENCIL here.

Listing~foo shows a typical usage pattern for the \code{clear} method.

\begin{lstlisting}[language=JavaScript]
gl = canvas.getContext('experimental-webgl', {antialias: true});
gl.clearColor(1, 1, 0, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
\end{lstlisting}

You'll find a \code{clear} call in almost every WebGL sample you ever examine, but it's not always required.  Some applications never even bother filling the background with a solid color; for example, consider an ``infinite tunnel'' game, as depicted on the far left in Figure~foo.  Since every pixel in the canvas is affected by 3D drawing commands, there's no need to clear the color buffer.  However, if the tunnel weren't infinite (middle in Figure~foo), there would be an area of the screen that never gets drawn to.  If you don't explicitly perform a clear before doing any drawing, this unpainted region might contain junk (right in Figure~foo).  This is because the pixels in canvas are simply a region of memory; if don't explicitly the clear memory, it'll contain retain whatever junky data happened to be sitting around.  This brings us to \code{preserveDrawingBuffer}

The \code{clear} command has an immediate* effect on the canvas, while \code{clearColor}, \code{clearDepth}, and \code{clearStencil} are simply configuring the WebGL state machine.  Most of the WebGL API consists of state-setting commands; there are only three methods in the entire API that can draw pixels into your canvas:

- clear
- drawArrays
- drawElements

We'll learn more about drawArrays and drawElements in the next chapter.

* It's not quite immediate!  The web browser and graphics driver can buffer up WebGL commands and execute them later.  Moreover the drawing commands usually paint on an offscreen surface or ``backbuffer'', which the browser then presents to the screen all at once.  For learning purposes however, it's fine to think to these actions as having an immediate effect.


images of a web page that has a background image (Egypt!)
each canvas should have an opaque perspective cube

0,0.25,.5,.5 -- no alpha, css-opacity=1
0,0.25,.5,.5 -- alpha without premultiplied, css-opacity=1
0,0.25,.5,.5 -- alpha with premultiplied, css-opacity=1

0,0.25,.5,.5 -- no alpha, css-opacity=.5
0,0.25,.5,.5 -- alpha without premultiplied, css-opacity=.5
0,0.25,.5,.5 -- alpha with premultiplied, css-opacity=.5

``Html Page Compositor''

MARGIN NOTE
\begin{comment}
In this book, we never author children of canvas, but there's nothing wrong with doing so.
\end{comment}

...

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Animation Timing}
\summary{How to periodically trigger draw events.}

\begin{lstlisting}[language=JavaScript]
  window.requestAnimationFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\rrecipe{Recipe 1: Strobe Light}
\summary{The simplest possible WebGL application; animates a solid color with \code{clear}.}

