\chapter{Preliminaries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WebGL and its Ancestry}
\summary{Gives an account of WebGL's ancestry (OpenGL, OpenGL ES), motivation, and rapid growth.  Also briefly mentions impediments at the time of writing, such as security concerns and IE support.}

3D graphics in the browser is not new.  One of the first technologies in this area was \index{VRML} VRML, the virtual reality modeling language standardized by the W3C in the mid 90's.  VRML was popular in academia but didn't quite have the same wildfire effect that characterizes the recent explosion of WebGL.

Why has WebGL left other 3D web technologies in the dust?  For one, it came along at just the right time; JavaScript only recently attained status as a serious platform for application development.  Sophisticated tools like Google's V8 \index{V8} engine  and John Resig's jQuery \index{jQuery} library have legitimized JavaScript in the eyes of developers coming from traditional desktop development.

WebGL has plenty of merits that make it more attractive than other browser-based 3D APIs.  Almost all popular browsers support it natively, freeing users from the overhead of plug-ins.  WebGL is also ``close to the metal'' -- by providing low-level access to graphics hardware, developers can maximize performance like never before.

WebGL's ancestry actually lies not in VRML (which did give rise to X3D and other standards) but in a low-level graphics API for C developed by Silicon Graphics in the early 90's.  They initially named their API \emph{IrisGL}, which evolved to \emph{OpenGL} when they released it as an industry standard.   With the rise of mobile platforms, OpenGL spawned OpenGL ES, which encompasses almost the same feature set of WebGL.  In a sense, WebGL is simply a JavaScript binding for OpenGL ES 2.0.

WebGL has another ancestor that is arguably just as influential as IrisGL: the Renderman Shading Language (RSL) developed by Pixar inspired much of the syntax in the language that WebGL provides for authoring \index{shaders} \emph{shaders}, relatively small routines executed with massive parallelism.  Shaders have the final say in the 3D position of every vertex, and the RGB color of every rasterized pixel.  We'll learn more about shaders in Chapter 2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Giza}
\summary{Describes our coding conventions and the \code{giza} library that is developed over the course of the book.}

This is not just a book, it's a library.  Many of the code listings in the book are lifted directly from the \emph{giza} library, named after the city in ancient Egypt.  The skyline of the Giza Necropolis is composed of triangles, the fundamental drawing primitive in computer graphics.  The pyramid shape also describes a \emph{viewing frustum}, a spatial region that encompasses everything within a certain vantage point in a 3D graphics program.

As a design philosphy, giza never calls methods on the WebGL context object -- that's your job!  We made this rule of thumb to ensure that we cover every detail of the API in the book, and to differentiate giza from higher-level libraries such as ThreeJS.  Instead of providing an abstraction of WebGL, giza provides utilities for performing vector math, constructing buffers of mesh data, and more.

All giza methods belong to a global object called \code{GIZA}, following the namespace convention common in JavaScript.  For example, here's how we define a small utility function that merges all attributes from object \code{b} into object \code{a}:

\begin{lstlisting}[language=JavaScript]
var GIZA = GIZA || {};

GIZA.merge = function (a, b) {
  for (var attrname in b) {
    a[attrname] = b[attrname];
  }
};
\end{lstlisting}

The first line allows clients to include a subset of Giza's source files by creating a \code{GIZA} namespace only if it doesn't already exist.  This isn't necessary when using giza in minified form, since the entire library is included in that case.

Other than \code{GIZA}, the only other global variables that we ever set are \code{COMMON} and \code{gl}.  The \code{gl} variable is the context object that exposes the entire WebGL API, which we'll learn about in Section~\ref{sec:context}.  We made this a global for terseness, since we make a huge number of calls to the context object.

The \code{COMMON} namespace is reserved for a few utility methods used in our recipes that don't belong to giza.  So, we came up with \code{COMMON} as a place to put a small handful of WebGL helpers that can be called from any recipe.  Unlike methods in \code{GIZA}, methods in \code{COMMON} are allowed to call jQuery functions and WebGL methods.

For access to the full source code to giza, or to download the minified library, refer to our github site:

\notetoself{http://to.be.filled.in.com}

Our github project also contains the code for all the recipes in this book, including the HTML and CSS source (and the \code{COMMON} layer).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Canvas Element}
\summary{Explains the \code{width} and \code{height} attributes and how to handle high-dpi displays (e.g., Apple Retina).}

The canvas element \index{\code{<canvas>} element} is one of the cornerstones of the HTML5 platform.  It provides rich drawing APIs for both 2D and 3D graphics.  The 2D API will not be discussed much in this book (except briefly in Chapter 8), and the 3D API is, of course, WebGL.

\subsection{Dealing with Size}

By default, \code{<canvas>} is a block level element, similar to \code{<div>}.  This means that it can only be a child of \code{<body>}, and that it's typically rendered with surrounding line breaks.

An important distinction between canvas and other elements is that it has two \index{size} sizes.  One size is the \emph{display area}, specified with familiar \index{CSS} CSS mechanisms.  The other size is the \emph{content size}, specified with explicit \code{width} \index{\code{width} attribute} and \code{height} \index{\code{height} attribute} attributes.  The content size specifies an off-screen drawing surface that gets scaled into the display area on the web page.

It's tempting to simply set the content and display sizes to the same dimensions, as in:

\begin{lstlisting}[language=HTML]
<canvas style="width:640px; height:360px"
        width="640" height="360">
</canvas>
\end{lstlisting}

There's nothing wrong with the above approach for simple applications.  It's common, however, to specify a dynamicly-sized display area rather than a fixed one (e.g., \code{width:100\%}).  Moreover CSS pixels don't necessarily correspond to actual device pixels.  This is especially true on displays with a high pixel density, where browsers typically upscale CSS pixels by 2x.

\begin{sidenote}
If you assume that device pixels are 1:1 with CSS pixels, you might see blurriness in your WebGL canvas due to upscaling.
\end{sidenote}

To get around these issues, \code{GIZA.init} (Listing~\ref{lst:GIZA:init1}) examines the \code{devicePixelRatio} window property to check how much upscaling is active.  It also examines the \code{clientWidth} \index{\code{clientWidth}, \code{clientHeight}} and \code{clientHeight} properties of the canvas element to obtain the finalized display area.

\begin{lstlisting}[
    caption={Adjusting the Canvas Size},
    label=lst:GIZA:init1,
    language=JavaScript]
GIZA.init = function(canvasElement) {

  // Find a canvas element if one wasn't specified.
  var canvas = canvasElement;
  if (!canvas) {
    canvas = document.getElementsByTagName('canvas')[0];
  }

  // Obtain the browser's upscale amount, assuming 1 if unavailable.
  var pixelScale = window.devicePixelRatio || 1;

  // Define a function that adjusts content size.
  var adjustSize = function() {
    var displayWidth = canvas.clientWidth;
    var displayHeight = canvas.clientHeight;
    canvas.width = displayWidth * pixelScale;
    canvas.height = displayHeight * pixelScale;
  };

  adjustSize();
  window.onresize = adjustSize;
\end{lstlisting} \index{\code{GIZA.init}}

In Listing~\ref{lst:GIZA:init1}, we adjust the canvas width and height not only during initialization, but also in response to the window's \index{\code{onresize} event} \code{onresize} event.

\begin{sidenote}
It's also common to adjust the WebGL \emph{viewport} and \emph{projection matrix} during a resize event.  More on this in future chapters.
\end{sidenote}

\subsection{Getting a Context}
\label{sec:context}

The entire WebGL API is exposed through an object of type \index{\code{WebGLRenderingContext}} \code{WebGLRenderingContext}, commonly known as the \index{draw context} \emph{draw context}.  It's obtained by calling \code{getContext} \index{\code{getContext} method} on a canvas element, like so:

\begin{lstlisting}[language=JavaScript]
  gl = canvas.getContext('experimental-webgl', {antialias: true});
\end{lstlisting}

At the time of this writing, \code{"experimental-webgl"} \index{\code{experimental-webgl}} is the only string that can be passed to \code{getContext} for WebGL.  (For the 2D canvas API, the string \code{"2d"} is used.)

The second argument is a set of optional attributes, as specified in Table~\ref{tab:ContextAttributes}.

\begin{table}[htb]\centering
  \begin{tabular}{lll}
    \hline
    Key & Default & Description \\
    \hline
    alpha & true & Alpha channel \\
    depth & true & Depth buffer \\
    stencil & false & Stencil buffer \\
    antialias & true & Enables multisampling \\
    premultipliedAlpha & true & Specifies compositing behavior; ignored if alpha is false \\
    preserveDrawingBuffer & false & Retains the canvas image from the previous draw cycle \\
    \hline
  \end{tabular}
  \caption{WebGL Context Options.}
  \label{tab:ContextAttributes}
\end{table}

We'll examine the attributes in Table~\ref{tab:ContextAttributes} in greater detail in the next section.

\notetoself{Add references to future sections in the book that deal with context loss and image capture.}

\subsection{Clearing the Canvas}

The only WebGL functions we're discussing in this chapter are the first two methods listed in Table~\ref{tab:Clearing}.

\begin{table}[htb]\centering
  \begin{tabular}{ll}
    \hline
    Method & Argument Types \\
    \hline
    clear(mask) & logical ``or'' of values in Table~\ref{tab:ClearBit} \\
    clearColor(red, green, blue, alpha)  & floating point numbers in [0,1] \\
    clearDepth(value) & floating point number in [0,1] \\
    clearStencil(mask) & integer \\
    \hline
  \end{tabular}
  \caption{WebGL Clear Methods.}
  \label{tab:Clearing}
\end{table}

The \code{clear} command changes the pixels in the canvas, while \code{clearColor}, \code{clearDepth}, and \code{clearStencil} are simply configuring the WebGL state machine.  Most of the WebGL API consists of state-setting commands; in fact there are only three methods in the entire API that can draw pixels into your canvas:

\begin{description}
\item[clear] Fill the color buffer (or depth/stencil).
\item[drawArrays] Draw 3D geometry defined by a sequential list of vertices.
\item[drawElements] Draw 3D geometry defined by a list of indices into a vertex buffer.
\end{description}

We'll learn more about \code{drawArrays} and \code{drawElements} in the next chapter.  Listing~\ref{lst:ClearCanvas} shows a usage example for the \code{clear} method.  It filles the canvas with a solid yellow color.

\begin{lstlisting}[
    caption={Clearing the canvas},
    label=lst:ClearCanvas,
    language=JavaScript]
gl = canvas.getContext('experimental-webgl', {antialias: true});
gl.clearColor(1, 1, 0, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
\end{lstlisting}

The \code{COLOR\_BUFFER\_BIT} flag is one of the constants that can be combined with a logical ``or'' to specify which drawing layers to include in the canvas.  To reduce the memory footprint, choose the fewest number of flags from Table~\ref{tab:ClearBit}.  In fact, don't worry about the depth and stencil layers just yet; we'll learn more about them in future chapters.

\begin{table}[htb]\centering
  \begin{tabular}{lll}
    \hline
    Property & Value & Default Value \\
    \hline
    \code{DEPTH\_BUFFER\_BIT}   & 0x0100 & 0.0 \\
    \code{STENCIL\_BUFFER\_BIT} & 0x0400 & 0x00000000\\
    \code{COLOR\_BUFFER\_BIT}   & 0x4000 & (0, 0, 0, 0) \\
    \hline
  \end{tabular}
  \caption{WebGL Clear Bits.}
  \label{tab:ClearBit}
\end{table}

You can find a \code{clear} call in most of the code samples in this book, but keep in mind that it's not always required.  Some applications never bother filling the background with a solid color.

For example, consider a game inside an infinite tunnel, as depicted on the far left in Figure~\ref{fig:Tunnel}.  Since every pixel in the canvas is affected by 3D drawing commands, there's no need to clear the color buffer.  If, however, the tunnel were finite (middle panel), there would be an area of the screen that never gets drawn to.  If you don't explicitly perform a clear before doing any drawing, the unpainted region might contain a ``dirty'' image (right panel), depending on the \code{preserveDrawingBuffer} option you chose when creating the context.  More on this in the next section.

\begin{figure}[htb]\centering
  \includegraphics[width=120mm]{Tunnels.png}
  \caption{The effects of \code{clear()} and \code{preserveDrawingBuffer}.  The closed tunnel on the far left does not need \code{clear()}.}
  \label{fig:Tunnel}
\end{figure}\index{tunnel}

\subsection{When is the canvas \emph{truly} updated?}
\label{sec:doublebuffer}

You might be familiar with \index{double-buffering} double-buffering if you've used other graphics APIs.  WebGL is always double-buffered.  This means that your drawing commands are actually affecting pixels in a \index{backbuffer} \emph{backbuffer}, which is an offscreen drawing surface.  The browser's render loop presents the finalized backbuffer to the screen in one fell swoop.  This creates the illusion of seamless animation by never allowing users to see a partially complete scene.

One side effect of double-buffering is that that the existing pixels you're overwriting do not necessarily correspond to what was drawn in the previous frame.  Normally this doesn't matter; most applications either clear the existing buffer, or fill it entirely with 3D drawing primitives.

In some situations you want the existing pixels to exactly match the previously-drawn frame.  For example, you might need to read color values from the canvas (the \index{\code{readPixels}} \code{readPixels} method will be discussed in \notetoself{CHAPTER}), or your application might intentionally update only certain regions of the canvas for performance reasons.  This is why \code{preserveDrawingBuffer} exists; it allows you to mimic \index{single-buffering} single-buffering.

You might be thinking: ``Okay, so the canvas isn't immediately updated when I call \code{clear} or \code{drawPixels}, but the \emph{backbuffer} is!''  Nope -- the web browser and the graphics driver are actually buffering up WebGL commands and executing them later.  If you'd like, you can tell WebGL to wait till the buffer is done executing by calling the \index{finish} \code{finish} method.  You'll rarely need this however, so don't use it unless you know you need it.

\subsection{Alpha Compositing}

If you're reading this book, you probably already know about the alpha channel, invented in the late 70's by Alvy Ray Smith, one of the co-founders of Pixar.

Alpha is usually a floating-point value in the [0,1] interval, treated much like the red, green, and blue components of pixel color.  Alpha can be thought of as the inverse of opacity, although WebGL can interpret it in many ways, as we'll learn in \notetoself{CHAPTER}.  For now we'll focus on the existence of the alpha channel in the canvas and how it interacts with the HTML page compositor in your browser.

Consider the case where the canvas is cleared to a half-opaque red color like so:

\begin{lstlisting}[language=JavaScript]
gl.clearColor(1, 0, 0, 0.5);
gl.clear(gl.COLOR_BUFFER_BIT);
\end{lstlisting}

If the \code{premultipledAlpha} option is disabled upon context creation, the RGB values in the canvas are multiplied by alpha before being added into the underlying color, as seen on the right in Figure~\ref{fig:PreMult}.

Another example would be clearing the background to (1, 1, 1, 0.5).  If \code{premultipledAlpha} is enabled in this case, the canvas woud seem completely opaque because adding white to any color yields white.  If \code{premultipledAlpha} were disabled, this would (crudely) brighten the background by averaging it with white.

\begin{figure}[htb]\centering
  \includegraphics[width=120mm]{PreMult.png}
  \caption{Semi-transparent canvas composed over a CSS \code{background-image}.}
  % http://en.wikipedia.org/wiki/File:BYR_color_wheel.svg
  \label{fig:PreMult}
\end{figure}

If the \code{alpha} option is disabled when creating a context, none of this matters -- the \code{premultipledAlpha} option is ignored.  The \code{alpha} option is enabled by default, as is \code{premultipledAlpha}.

\begin{comment}
Note that we're not addressing css-opacity.

In this book, we never add children elements to \code{<canvas>}, but there's nothing wrong with doing so.  On some platforms, this can degrade performance, although this is improving as WebGL implementations are maturing.

http://www.svgopen.org/2005/papers/abstractsvgopen/
http://stackoverflow.com/questions/9491417/when-webgl-decide-to-update-the-display?answertab=votes#tab-top

\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Animation Timing}
\summary{How to periodically trigger draw events.}

You wouldn't be learning WebGL unless you were interested in animation.  WebGL applications generally issue all rendering commands for a given 3D scene in a \emph{draw cycle}.  The easiest but also most naive way of doing this in JavaScript is \code{setInterval}:

\begin{lstlisting}[language=JavaScript]
// Call myDrawFunc() every 60th of a second
var delay = 1 / 60;
window.setInterval(myDrawFunc, delay / 1000);
\end{lstlisting}

The above approach isn't ideal for high-performing 3D graphics -- it's preferable to hook in to the browser's native rendering loop.  This allows your animation routine to become idle if the browser has no need to draw itself (e.g., if the window is minimized), saving precious battery life and CPU cycles.  It also aligns animation with the refresh rate of the monitor, preventing chopiness.

At the time of this writing, all major browsers supply a method on \code{window} exactly for this purpose, although it has a vendor-specific prefix until it becomes fully standardized.  Giza's \code{init} function handles this for you, as seen in Listing~\ref{lst:GIZA:init2}

\begin{lstlisting}[
    caption={Initializing \code{requestAnimationFrame}},
    label=lst:GIZA:init2,
    language=JavaScript]
GIZA.init = function(canvasElement) {

  ... // Replace ellipses with Listing~\ref{lst:GIZA:init1}

  window.requestAnimationFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;
\end{lstlisting} \index{\code{GIZA.init}}

It's important to note that \code{requestAnimationFrame} is actually more like \code{setTimeout} than \code{setInterval} in that you need to call it again if you wish another draw cycle to occur.  We provide a function in the \code{COMMON} namespace that can be called at the end of your function to request another draw cycle, and to check the WebGL error state.  This is good practice to ensure clean, error-free code.  See Listing~\ref{lst:COMMON:endFrame}.

\begin{lstlisting}[
    caption={Common end-of-frame tasks.},
    label=lst:COMMON:endFrame,
    language=JavaScript]
  var err = gl.getError();
  if (err != gl.NO_ERROR) {
    console.error("WebGL error during draw cycle: ", err);
    // Don't request another draw cycle here;
    // this prevents an infinite cascade of errors.
  } else {
    window.requestAnimationFrame(wrappedDrawFunc, GIZA.canvas);
  }
\end{lstlisting} \index{\code{COMMON.endframe}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Recipe 1: Strobe Light}
\summary{The simplest possible WebGL application; animates a solid color with \code{clear}.}

Every chapter in this book ends with \emph{recipe} that walks through all the code for a certain giza demo.  Each recipe has fairly simple HTML, as seen in Figure~\ref{fig:Recipe1}.

\begin{figure}[htb]\centering
  \includegraphics[width=120mm]{Recipe1.png}
  \caption{Examples of ``recipes'': \code{StrobeLight} from Chapter 1 and \code{BasicLighting} from Chapter 4.}
  \label{fig:Recipe1}
\end{figure}

This chapter's recipe is called \code{StrobeLight}, which isn't too exciting but at least establishes the boilerplate we'll be using for future recipes.  First let's take a look at its HTML; see Listing~\ref{lst:StrobeLight1}.

\begin{lstlisting}[
    caption={\code{StrobeLight.html}},
    label=lst:StrobeLight1,
    language=HTML]
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>StrobeLight</title>
    <link href="css/style.css" rel="stylesheet">
    <script src="lib/head.load.min.js"></script>
    <script src="common.js"></script>
    <script src="StrobeLight.js"></script>
  </head>
  <body>
    <h1>Strobe Light</h1>
    <div class="tagline">
      The only shader-free recipe!
    </div>
    <canvas style="width:640;height:360px">
    </canvas>
    <div id="button-bar">
    </div>
  </body>
</html>
\end{lstlisting} \index{\code{StrobeLight.html}}

While giza has no dependencies on any JavaScript libraries, the COMMON layer does use some libraries to make life a little easier.

\begin{description}
\item[head.js] TODO 
\item[stats.js] TODO
\item[jQuery] TODO
\end{description}

Next up see Listing~\ref{lst:COMMON:file}.  TBD

\begin{lstlisting}[
    caption={\code{common.js}},
    label=lst:COMMON:file,
    language=JavaScript]
// Create a COMMON namespace for a small handful of helper functions
// and constants.
var COMMON = {cdn: "http://ajax.googleapis.com/ajax/libs/"};

// Use HeadJS to load scripts asynchronously, but execute them
// synchronously.
head.js(
  "lib/giza.min.js",
  "lib/stats.min.js",
  COMMON.cdn + "jquery/1.8.0/jquery.min.js",
  COMMON.cdn + "jqueryui/1.9.2/jquery-ui.min.js");

// After all scripts have been loaded AND after the document is
// "Ready", execute the recipe's main() function.
head.ready(main);

... // Replace ellipses with Listing~\ref{lst:COMMON:endFrame}.
\end{lstlisting} \index{\code{common.js}}

Next up see Listing~\ref{lst:StrobeLight2}.  TBD

\begin{lstlisting}[
    caption={\code{StrobeLight.js}},
    label=lst:StrobeLight2,
    language=JavaScript]
var main = function() {

  GIZA.init();

  var draw = function(currentTime) {
    var x = 0.5 + 0.5 * Math.sin(currentTime / 100);
    x = 0.25 + x * 0.5;
    gl.clearColor(x, x, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    COMMON.endFrame(draw);
  };

  draw(0);

};
\end{lstlisting} \index{\code{StrobeLight.js}}

TBD.